/******************************************************************************
 * @file    AprxContext.h
 * @author  Antonio Tammaro
 * @date    20 gen 2017
 * @brief   AprxContext header file.
 * @details TODO
 *          
 ******************************************************************************/

#ifndef INCLUDE_BELLEROPHON_APRXCONTEXT_H_
#define INCLUDE_BELLEROPHON_APRXCONTEXT_H_

#include "Core/AprxTechnique.h"

namespace bellerophon{
namespace core{

struct AprxLocation;
// Typedef
using AprxLocationVector = ::std::vector<AprxLocation>;
using AprxGrade = short;

// Types
/// \brief Bind between an AprxTechnique and an aprxGrade that can be 'accumulated'
struct AprxLocation {
    /// \brief Constructor
    AprxLocation ( ::std::shared_ptr<AprxTechnique> t = nullptr,
                   AprxGrade grade = 1 )
        : technique ( t ),
          g ( grade ) {}

    ::std::shared_ptr<AprxTechnique> technique;
    AprxGrade g;  
    /// \brief Overloadin = operator
    AprxLocation operator= (const AprxLocation &rhs){
      AprxLocation r(rhs.technique,rhs.g);
      return r;
    }
};


class AprxContext;

// Typedef
using AprxContextPtr  = AprxContext*;
using AprxContextIdTy = ::std::string;

class AprxContext{

public:
  //*-------------------------------------------------------------------*
  // Contructor
  //*-------------------------------------------------------------------*
  AprxContext(){} 

  explicit AprxContext (AprxContextIdTy id, const ::std::string& desc)
        : Id ( id ),  Desc ( desc ), LocStartId(0){}

  
  virtual ~AprxContext(){}
  //*-------------------------------------------------------------------*
  // Get Methods
  //*-------------------------------------------------------------------*
  AprxContextIdTy     getId()       { return this->Id; }
  ::std::string       getDesc()     { return this->Desc; } 
  AprxLocationVector  getLocations(){ return this->locations; } 
  unsigned int        getLocNumb()  { return this->locations.size();} 
  //*-------------------------------------------------------------------*
  // Functional Methods 
  //*-------------------------------------------------------------------*
  virtual AprxContext* operator= (AprxContext &rhs) = 0;  

  /// Location mangment methods
  void addLocation( ::std::shared_ptr<AprxTechnique> );
  void addLocations( const ::std::vector<::std::shared_ptr<AprxTechnique>> );

  virtual void setLocation ( const ::std::vector<AprxLocation> ) = 0;

  void printLocation ( );
  void printLocation (const AprxLocationVector& locations );
    
  bool isEmptyLoc(){ return this->locations.empty(); }
  
  /// \brief Virtual Method read report
  /// \detailed Read approximation report generated by clang-chimera tools
  //    initialize the AprxLocationVector
  /// \return Return true if everything goes right
  //bool readReport(::std::string report);
  virtual bool readReport(::std::string report) = 0;
  /// \brief Get the maximum approximation grade
  /// \return Maximum approximation grade applicable
  virtual ::bellerophon::core::AprxGrade getMaxApplicableGrade() const = 0;
  
protected:

  AprxContextIdTy    Id;         //< Identifier
  ::std::string      Desc;       //< Description string
  AprxLocationVector locations;  //< Locations on which apply approximation
  unsigned LocStartId;           //< Location Start Id
}; // end class AprxContext
}// end core namespace 
}// end bellerophon namespace

#endif/* INCLUDE_BELLEROPHON_APRXCONTEXT_H_ */
